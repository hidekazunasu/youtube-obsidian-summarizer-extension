import type { ExtensionSettings, NotePayload, SaveResult, SummaryResult, VideoData } from './types';

interface SaveToNotionDeps {
  fetchImpl?: typeof fetch;
}

const NOTION_API_URL = 'https://api.notion.com/v1/pages';
const NOTION_VERSION = '2022-06-28';
const MAX_NOTION_BLOCKS = 100;
const MAX_BLOCK_TEXT_LENGTH = 1_900;

export async function saveToNotion(
  note: NotePayload,
  video: VideoData,
  summary: SummaryResult,
  settings: ExtensionSettings,
  deps: SaveToNotionDeps = {}
): Promise<SaveResult> {
  const fetchImpl = deps.fetchImpl ?? fetch;

  try {
    const title = buildNotionTitle(note.path, video.videoId, video.title);
    const children = buildNotionParagraphBlocks(note.content, summary.model);

    const response = await fetchImpl(NOTION_API_URL, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${settings.notionApiToken}`,
        'Notion-Version': NOTION_VERSION,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        parent: { page_id: settings.notionParentPageId.trim() },
        properties: {
          title: {
            title: [
              {
                type: 'text',
                text: { content: title }
              }
            ]
          }
        },
        children
      })
    });

    if (!response.ok) {
      const body = await response.text();
      return {
        status: 'failed',
        message: `Notion API failed (${response.status}): ${body.slice(0, 300)}`
      };
    }

    return {
      status: 'notion_saved',
      message: `Notion page created: ${title}`
    };
  } catch (error) {
    return {
      status: 'failed',
      message: `Notion save failed: ${toMessage(error)}`
    };
  }
}

function buildNotionTitle(path: string, videoId: string, videoTitle: string): string {
  const withoutExt = path.replace(/\.md$/i, '');
  const lastSlash = withoutExt.lastIndexOf('/');
  const fromPath = lastSlash >= 0 ? withoutExt.slice(lastSlash + 1) : withoutExt;
  const normalized = fromPath.trim();
  if (normalized) {
    return normalized.slice(0, 180);
  }
  return `${videoTitle}_${videoId}`.slice(0, 180);
}

function buildNotionParagraphBlocks(content: string, model: string): Array<Record<string, unknown>> {
  const blocks: Array<Record<string, unknown>> = [];
  const lines = content
    .split(/\r?\n/g)
    .map((line) => line.trimEnd())
    .filter((line) => line.length > 0);

  if (lines.length === 0) {
    return [buildParagraphBlock(`Generated by ${model}`)];
  }

  let truncated = false;

  for (const line of lines) {
    const chunks = chunkText(line, MAX_BLOCK_TEXT_LENGTH);
    for (const chunk of chunks) {
      if (blocks.length >= MAX_NOTION_BLOCKS - 1) {
        truncated = true;
        break;
      }
      blocks.push(buildParagraphBlock(chunk));
    }

    if (truncated) {
      break;
    }
  }

  if (truncated) {
    blocks.push(buildParagraphBlock('[content truncated for Notion block limit]'));
  }

  return blocks;
}

function buildParagraphBlock(content: string): Record<string, unknown> {
  return {
    object: 'block',
    type: 'paragraph',
    paragraph: {
      rich_text: [
        {
          type: 'text',
          text: {
            content
          }
        }
      ]
    }
  };
}

function chunkText(text: string, limit: number): string[] {
  if (text.length <= limit) {
    return [text];
  }

  const output: string[] = [];
  for (let i = 0; i < text.length; i += limit) {
    output.push(text.slice(i, i + limit));
  }
  return output;
}

function toMessage(value: unknown): string {
  if (value instanceof Error) {
    return value.message;
  }
  return String(value);
}
